<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="6.3 Forecasting | Educated Guess" />
<meta property="og:type" content="book" />
<meta property="og:image" content="/forecasting-logo.png" />
<meta property="og:description" content="Forecasting With Time Series Models Using R" />


<meta name="author" content="David Ubilava" />


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<meta name="description" content="Forecasting With Time Series Models Using R">

<title>6.3 Forecasting | Educated Guess</title>

<link href="libs/tufte-css-2015.12.29/tufte-fonts.css" rel="stylesheet" />
<link href="libs/tufte-css-2015.12.29/tufte-background.css" rel="stylesheet" />
<link href="libs/tufte-css-2015.12.29/tufte-italics.css" rel="stylesheet" />
<link href="libs/tufte-css-2015.12.29/tufte.css" rel="stylesheet" />


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<style type="text/css">
/* Used with Pandoc 2.11+ new --citeproc when CSL is used */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>

<link rel="stylesheet" href="style.css" type="text/css" />

</head>

<body>



<div class="row">
<div class="col-sm-12">
<!--bookdown:toc:end-->
<!--bookdown:toc:start-->
</div>
</div>
<div class="row">
<div class="col-sm-12">
<div id="forecasting-2" class="section level2" number="6.3">
<h2><span class="header-section-number">6.3</span> Forecasting</h2>
<p>Making forecasts for some future period, <span class="math inline">\(t+h\)</span>, from an AR(p) model that has been fit to the data up to and including period <span class="math inline">\(t+h-1\)</span> can be a straightforward exercise, so long as we have access to such data. That is the case for one-step-ahead forecasts, that is when <span class="math inline">\(h=1\)</span>, for which the information set is readily available. For multi-step-ahead forecasts, that is when <span class="math inline">\(h&gt;1\)</span>, this no longer it the case. There are two approaches or methods of multi-step-ahead forecasting that can allowe us to circumvent the issue.</p>
<div id="iterative-method-of-multistep-forecasting" class="section level3" number="6.3.1">
<h3><span class="header-section-number">6.3.1</span> Iterative Method of Multistep Forecasting</h3>
<p>One approach involves ‘coming up’ with the value of the variable that has not been realized yet. For example, when making a two-step-ahead forecast for period <span class="math inline">\(t+2\)</span>, we need data from period <span class="math inline">\(t+1\)</span>, which is not available at the time when the forecast is made. Instead, we need to use our forecast for period <span class="math inline">\(t+1\)</span>. The same applies to forecasts for any subsequent periods in the future. This approach is known as an <em>iterative</em> method of forecasting, wherein we make forecast for some period using the available data, then iterate forward by one period and use the most recent forecast to make the next period’s forecast, and so on and so forth.</p>
<p>Consider an AR(p) model. A future realization of the random variable is <span class="math display">\[y_{t+h} = \alpha + \beta_1 y_{t+h-1} + \cdots  + \beta_p y_{t+h-p}+\varepsilon_{t+h}\]</span></p>
<p>Point forecast (ignoring parameter uncertainty) is: <span class="math display">\[y_{t+h|t} = E(y_{t+h}|\Omega_t) = \alpha + \beta_1 y_{t+h-1|t} + \cdots  + \beta_p y_{t+h-p|t},\]</span> where <span class="math inline">\(y_{t+h-j|t}=y_{t+h-j}\)</span> when <span class="math inline">\(h-j\le 0\)</span>. That is, for a given time period, we use the realization of the random variable if it is observed, otherwise we use the point forecast of the realization.</p>
<p>Forecast error: <span class="math display">\[e_{t+h|t} = y_{t+h} - y_{t+h|t} = \beta_1 e_{t+h-1|t} + \cdots  + \beta_p e_{t+h-p|t} + \varepsilon_{t+h},\]</span> where <span class="math inline">\(e_{t+h-j|t}=0\)</span> when <span class="math inline">\(h-j\le 0\)</span>. So, when <span class="math inline">\(h=1\)</span>, <span class="math inline">\(e_{t+1|t}=\varepsilon_{t+1}\)</span>, which is the same as with previously described models (e.g., trend or seasonal models), but when <span class="math inline">\(h&gt;1\)</span>, forecast error becomes more complex.</p>
<p>The forecast variance: <span class="math display">\[\sigma_{t+h|t}^2 = \sigma_{\varepsilon}^2 + \sum_{i=1}^{p}\beta_i^2 Var(e_{t+h-i|t}) + 2\sum_{i \neq j}\beta_i\beta_j Cov(e_{t+h-i|t},e_{t+h-j|t})\]</span>
These variance and covariances of forecast errors from preceding horizons are some functions of the in-sample error variance and model parameters.</p>
<p>The 95% interval forecast is: <span class="math display">\[y_{t+h|t} \pm 1.96 \hat{\sigma}_{\varepsilon}.\]</span></p>
<p>To illustrate the foregoing, let’s revisit the USD/EUR exchange rate series, and obtain point and interval forecasts for periods from January 2011 onward based on parameter estimates of the second-order autoregression using data up to and including December 2010.</p>
<div class="figure"><span style="display:block;" id="fig:forexchange"></span>
<img src="forecasting_files/figure-html/forexchange-1.png" alt="Second-order autoregression" width="600" />
<p class="caption marginnote shownote">
Figure 6.4: Second-order autoregression
</p>
</div>
</div>
<div id="direct-method-of-multistep-forecasting" class="section level3" number="6.3.2">
<h3><span class="header-section-number">6.3.2</span> Direct Method of Multistep Forecasting</h3>
<p>The other approach entails directly obtaining multi-step-ahead forecasts. To illustrate, consider a first-order autoregression: <span class="math inline">\(y_t=\alpha+\beta_1 y_{t-1}+\varepsilon_t.\)</span></p>
<p>One-step-ahead point forecast is readily given by: <span class="math inline">\(y_{t+1|t}=\alpha+\beta_1 y_{t}\)</span>. That is, we observe all the variables on the right-hand side of the equation.</p>
<p>To generate the two-step-ahead forecast in a similar manner, that is by ensuring the observed variables on the right-hand side of the equation, we can substitute <span class="math inline">\(y_{t-1}=\alpha+\beta_1 y_{t-2}+\varepsilon_{t-1}\)</span> into the original equation to obtain: <span class="math display">\[y_t=\alpha(1+\beta_1)+\beta_1^2y_{t-2} + \varepsilon_t + \beta_1\varepsilon_{t-1} = \tilde{\alpha} + \tilde{\beta}_1 y_{t-2} + u_t,\]</span> where <span class="math inline">\(\tilde{\alpha}=\alpha(1+\beta_1)\)</span> and <span class="math inline">\(\tilde{\beta}_1=\beta_1^2\)</span>, and <span class="math inline">\(u_t=\varepsilon_t + \beta_1\varepsilon_{t-1}.\)</span></p>
<p>Thus, we can obtain two-step-ahead forecast in a manner similar to that when we obtain one-step-ahead forecast by regressing <span class="math inline">\(y_t\)</span> on <span class="math inline">\(y_{t-2}\)</span>, and then directly forecasting <span class="math inline">\(y_{t+2}\)</span> from <span class="math inline">\(y_{t}\)</span>.</p>
<p>This <em>direct</em> method of multi-step-ahead forecasting can be extended to higher order autoregression, as well as to any forecast horizon.</p>
<p>In the direct method, error terms are serially correlated (by construction).<label for="tufte-sn-14" class="margin-toggle sidenote-number">14</label><input type="checkbox" id="tufte-sn-14" class="margin-toggle"><span class="sidenote"><span class="sidenote-number">14</span> Recall that multi-step-ahead forecast errors tend to be serially correlated. So, direct method merely maintains this feature of multistep forecasts.</span> For example, in the direct two-step-ahead forecast from a re-specified AR(1) model, as we saw: <span class="math inline">\(u_t = \varepsilon_t+\beta_1\varepsilon_{t-1}\)</span>. It then follows that: <span class="math display">\[\sigma^2_u = E\left[(\varepsilon_t+\beta_1\varepsilon_{t-1})^2\right] = \sigma^2_{\varepsilon}(1+\beta_1^2).\]</span></p>
<p>This is also the expression of the two-step-ahead forecast error variance under the iterated method.</p>
<p>Thus, when applying the direct method of forecasting, interval forecasts for a given horizon are obtained ‘directly,’ based on the standard deviation of the residuals.</p>
<p>The relative performance of forecasts from the considered two methods—iterative and direct—in terms of bias and efficiency depends on the bias and efficiency of the estimators of each method.</p>
<p>Assuming the autoregressive model is correctly specified, both methods are consistent, but the iterative method is more efficient. Thus, in large samples, the iterative forecast can be expected to perform better than the direct forecast.</p>
<p>In the case of a mis-specified model, however, the direct method may as well outperform the iterated method.</p>

</div>
</div>
<!-- </div> -->
<p style="text-align: center;">
<a href="6.2-modeling-2.html"><button class="btn btn-default">Previous</button></a>
<a href="7-vector-autoregression.html"><button class="btn btn-default">Next</button></a>
</p>
</div>
</div>



</body>
</html>
